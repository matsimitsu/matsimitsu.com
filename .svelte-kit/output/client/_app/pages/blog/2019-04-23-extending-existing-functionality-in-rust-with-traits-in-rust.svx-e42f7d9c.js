import{S as a,i as n,s,A as e,j as t,m as o,o as c,p,v as r,r as u,w as i,q as l,e as d,t as k,k as h,c as m,a as f,g,d as w,n as v,b as E,f as y,E as b,G as P}from"../../chunks/vendor-f5a3c274.js";import{M as C}from"../../chunks/_mdsvex-0fbf9182.js";import"../../chunks/stores-0da78aa4.js";import"../../chunks/FormattedDate-b4a44e35.js";function x(a){let n,s,e,t,o,c,p,r,u,i,l,C,x,T,_,A,$,O,R,D,I,L,M,W,N,j,B,K,S,q,H,G,U,Y,F,Q,V,Z,z,J,X,aa,na,sa,ea,ta,oa,ca,pa,ra,ua,ia,la,da,ka,ha,ma,fa,ga,wa,va,Ea,ya,ba,Pa,Ca,xa,Ta,_a,Aa,$a,Oa,Ra,Da,Ia,La,Ma,Wa,Na,ja,Ba,Ka,Sa,qa,Ha,Ga,Ua,Ya,Fa,Qa,Va,Za,za,Ja;return{c(){n=d("p"),s=k("At AppSignal we use Protobuf to pass messages through Kafka. We picked this because we were already using Protobuf in our Agent and it works great for our use-case."),e=h(),t=d("p"),o=k("One of the benefits of Protobuf is that it generates Rust code based on the protocol definition, which we can extend through traits to add additional features."),c=h(),p=d("p"),r=k("A common thing we have to do in our processing pipeline is to merge two messages into one, e.g. merge two (count) metrics."),u=h(),i=d("p"),l=k("In this case we want to merge two "),C=d("code"),x=k("Counter"),T=k(" messages that look like this:"),_=h(),A=d("pre"),$=h(),O=d("p"),R=k("We can generate a Rust implementation of this protocol with "),D=d("code"),I=k("protoc"),L=k(" and extend this protocol using a trait."),M=h(),W=d("blockquote"),N=d("p"),j=k("A "),B=d("strong"),K=k("trait"),S=k(" can be used to define functionality a type must provide. You can also implement default methods for a trait that can be overridden."),q=h(),H=d("p"),G=k("In this case we implement a default function for our "),U=d("code"),Y=k("CounterExt"),F=k(" trait."),Q=h(),V=d("pre"),Z=h(),z=d("p"),J=k("In the code above we use the "),X=d("code"),aa=k("protobuf"),na=k(" crate and define the generated Rust code with "),sa=d("code"),ea=k("protoc"),ta=k(" as a public module. We also use the "),oa=d("code"),ca=k("Counter"),pa=k(" message we defined in the protocol. Then we define a new trait for the counter, called CounterExt."),ra=h(),ua=d("p"),ia=k("This code defines a new function for CounterExt, called "),la=d("code"),da=k("merge"),ka=k(" that accepts another counter to merge."),ha=h(),ma=d("p"),fa=k("Next up we need to create a default implementation for this function."),ga=h(),wa=d("pre"),va=h(),Ea=d("p"),ya=k("In this method we take the given counter and add it’s value to "),ba=d("code"),Pa=k("self"),Ca=k("."),xa=h(),Ta=d("p"),_a=k("Now that we have created this trait with a default implementation we can use it to merge two counters directly on the Protobuf generated code."),Aa=h(),$a=d("p"),Oa=k("This means we can operate directly on deserialised Protobuf messages without having to convert them to structs or create a new message to contain the computed value."),Ra=h(),Da=d("pre"),Ia=h(),La=d("p"),Ma=k("The code above gets called for each Kafka message and updates a local cache with the merged value of the received message if it exists."),Wa=h(),Na=d("p"),ja=k("And it inserts the message into the cache if it doesn’t already exist."),Ba=h(),Ka=d("p"),Sa=k("By extending our Protobuf messages with default traits we save ourselvs a lot of hassle in the message processing function."),qa=h(),Ha=d("p"),Ga=k("Besides merging we implement a few other methods on our Protobuf messages that handle merging and computation of quantiles/percentiles/mean values."),Ua=h(),Ya=d("p"),Fa=k("Like this article or have any comments? Contact me on "),Qa=d("a"),Va=k("twitter"),Za=k(" or by "),za=d("a"),Ja=k("hello@matsimitsu.com"),this.h()},l(a){n=m(a,"P",{});var d=f(n);s=g(d,"At AppSignal we use Protobuf to pass messages through Kafka. We picked this because we were already using Protobuf in our Agent and it works great for our use-case."),d.forEach(w),e=v(a),t=m(a,"P",{});var k=f(t);o=g(k,"One of the benefits of Protobuf is that it generates Rust code based on the protocol definition, which we can extend through traits to add additional features."),k.forEach(w),c=v(a),p=m(a,"P",{});var h=f(p);r=g(h,"A common thing we have to do in our processing pipeline is to merge two messages into one, e.g. merge two (count) metrics."),h.forEach(w),u=v(a),i=m(a,"P",{});var E=f(i);l=g(E,"In this case we want to merge two "),C=m(E,"CODE",{});var y=f(C);x=g(y,"Counter"),y.forEach(w),T=g(E," messages that look like this:"),E.forEach(w),_=v(a),A=m(a,"PRE",{class:!0}),f(A).forEach(w),$=v(a),O=m(a,"P",{});var b=f(O);R=g(b,"We can generate a Rust implementation of this protocol with "),D=m(b,"CODE",{});var P=f(D);I=g(P,"protoc"),P.forEach(w),L=g(b," and extend this protocol using a trait."),b.forEach(w),M=v(a),W=m(a,"BLOCKQUOTE",{});var Xa=f(W);N=m(Xa,"P",{});var an=f(N);j=g(an,"A "),B=m(an,"STRONG",{});var nn=f(B);K=g(nn,"trait"),nn.forEach(w),S=g(an," can be used to define functionality a type must provide. You can also implement default methods for a trait that can be overridden."),an.forEach(w),Xa.forEach(w),q=v(a),H=m(a,"P",{});var sn=f(H);G=g(sn,"In this case we implement a default function for our "),U=m(sn,"CODE",{});var en=f(U);Y=g(en,"CounterExt"),en.forEach(w),F=g(sn," trait."),sn.forEach(w),Q=v(a),V=m(a,"PRE",{class:!0}),f(V).forEach(w),Z=v(a),z=m(a,"P",{});var tn=f(z);J=g(tn,"In the code above we use the "),X=m(tn,"CODE",{});var on=f(X);aa=g(on,"protobuf"),on.forEach(w),na=g(tn," crate and define the generated Rust code with "),sa=m(tn,"CODE",{});var cn=f(sa);ea=g(cn,"protoc"),cn.forEach(w),ta=g(tn," as a public module. We also use the "),oa=m(tn,"CODE",{});var pn=f(oa);ca=g(pn,"Counter"),pn.forEach(w),pa=g(tn," message we defined in the protocol. Then we define a new trait for the counter, called CounterExt."),tn.forEach(w),ra=v(a),ua=m(a,"P",{});var rn=f(ua);ia=g(rn,"This code defines a new function for CounterExt, called "),la=m(rn,"CODE",{});var un=f(la);da=g(un,"merge"),un.forEach(w),ka=g(rn," that accepts another counter to merge."),rn.forEach(w),ha=v(a),ma=m(a,"P",{});var ln=f(ma);fa=g(ln,"Next up we need to create a default implementation for this function."),ln.forEach(w),ga=v(a),wa=m(a,"PRE",{class:!0}),f(wa).forEach(w),va=v(a),Ea=m(a,"P",{});var dn=f(Ea);ya=g(dn,"In this method we take the given counter and add it’s value to "),ba=m(dn,"CODE",{});var kn=f(ba);Pa=g(kn,"self"),kn.forEach(w),Ca=g(dn,"."),dn.forEach(w),xa=v(a),Ta=m(a,"P",{});var hn=f(Ta);_a=g(hn,"Now that we have created this trait with a default implementation we can use it to merge two counters directly on the Protobuf generated code."),hn.forEach(w),Aa=v(a),$a=m(a,"P",{});var mn=f($a);Oa=g(mn,"This means we can operate directly on deserialised Protobuf messages without having to convert them to structs or create a new message to contain the computed value."),mn.forEach(w),Ra=v(a),Da=m(a,"PRE",{class:!0}),f(Da).forEach(w),Ia=v(a),La=m(a,"P",{});var fn=f(La);Ma=g(fn,"The code above gets called for each Kafka message and updates a local cache with the merged value of the received message if it exists."),fn.forEach(w),Wa=v(a),Na=m(a,"P",{});var gn=f(Na);ja=g(gn,"And it inserts the message into the cache if it doesn’t already exist."),gn.forEach(w),Ba=v(a),Ka=m(a,"P",{});var wn=f(Ka);Sa=g(wn,"By extending our Protobuf messages with default traits we save ourselvs a lot of hassle in the message processing function."),wn.forEach(w),qa=v(a),Ha=m(a,"P",{});var vn=f(Ha);Ga=g(vn,"Besides merging we implement a few other methods on our Protobuf messages that handle merging and computation of quantiles/percentiles/mean values."),vn.forEach(w),Ua=v(a),Ya=m(a,"P",{});var En=f(Ya);Fa=g(En,"Like this article or have any comments? Contact me on "),Qa=m(En,"A",{href:!0,rel:!0});var yn=f(Qa);Va=g(yn,"twitter"),yn.forEach(w),Za=g(En," or by "),za=m(En,"A",{href:!0});var bn=f(za);Ja=g(bn,"hello@matsimitsu.com"),bn.forEach(w),En.forEach(w),this.h()},h(){E(A,"class","language-protobuf"),E(V,"class","language-rust"),E(wa,"class","language-rust"),E(Da,"class","language-rust"),E(Qa,"href","https://twitter.com/matsimitsu"),E(Qa,"rel","nofollow"),E(za,"href","mailto:hello@matsimitsu.com")},m(a,d){y(a,n,d),b(n,s),y(a,e,d),y(a,t,d),b(t,o),y(a,c,d),y(a,p,d),b(p,r),y(a,u,d),y(a,i,d),b(i,l),b(i,C),b(C,x),b(i,T),y(a,_,d),y(a,A,d),A.innerHTML='<code class="language-protobuf"><span class="token keyword">message</span> <span class="token class-name">Counter</span> <span class="token punctuation">&#123;</span>\n  <span class="token builtin">int64</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">&#125;</span></code>',y(a,$,d),y(a,O,d),b(O,R),b(O,D),b(D,I),b(O,L),y(a,M,d),y(a,W,d),b(W,N),b(N,j),b(N,B),b(B,K),b(N,S),y(a,q,d),y(a,H,d),b(H,G),b(H,U),b(U,Y),b(H,F),y(a,Q,d),y(a,V,d),V.innerHTML='<code class="language-rust"><span class="token keyword">extern</span> <span class="token keyword">crate</span> <span class="token module-declaration namespace">protobuf</span><span class="token punctuation">;</span>\n\n<span class="token keyword">pub</span> <span class="token keyword">mod</span> <span class="token module-declaration namespace">protocol</span><span class="token punctuation">;</span>\n\n<span class="token keyword">use</span> <span class="token namespace">protocol<span class="token punctuation">::</span></span><span class="token class-name">Counter</span><span class="token punctuation">;</span>\n\n<span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token class-name">CounterExt</span> <span class="token punctuation">&#123;</span>\n    <span class="token keyword">fn</span> <span class="token function-definition function">merge</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> to_merge<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Counter</span><span class="token punctuation">)</span>\n<span class="token punctuation">&#125;</span></code>',y(a,Z,d),y(a,z,d),b(z,J),b(z,X),b(X,aa),b(z,na),b(z,sa),b(sa,ea),b(z,ta),b(z,oa),b(oa,ca),b(z,pa),y(a,ra,d),y(a,ua,d),b(ua,ia),b(ua,la),b(la,da),b(ua,ka),y(a,ha,d),y(a,ma,d),b(ma,fa),y(a,ga,d),y(a,wa,d),wa.innerHTML='<code class="language-rust">\n<span class="token keyword">impl</span> <span class="token class-name">CounterExt</span> <span class="token keyword">for</span> <span class="token class-name">Counter</span> <span class="token punctuation">&#123;</span>\n    <span class="token keyword">fn</span> <span class="token function-definition function">merge</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> to_merge<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Counter</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>\n        <span class="token keyword">let</span> our_count <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">get_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">set_count</span><span class="token punctuation">(</span>our_count <span class="token operator">+</span> to_merge<span class="token punctuation">.</span><span class="token function">get_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">&#125;</span>\n<span class="token punctuation">&#125;</span>\n</code>',y(a,va,d),y(a,Ea,d),b(Ea,ya),b(Ea,ba),b(ba,Pa),b(Ea,Ca),y(a,xa,d),y(a,Ta,d),b(Ta,_a),y(a,Aa,d),y(a,$a,d),b($a,Oa),y(a,Ra,d),y(a,Da,d),Da.innerHTML='<code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">rdkafka<span class="token punctuation">::</span>message<span class="token punctuation">::</span></span><span class="token class-name">ProtobufMessage</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Use the protocol Counter and the trait.</span>\n<span class="token keyword">use</span> <span class="token namespace">protocol<span class="token punctuation">::</span>protocol<span class="token punctuation">::</span></span><span class="token class-name">Counter</span><span class="token punctuation">;</span>\n<span class="token keyword">use</span> <span class="token namespace">protocol<span class="token punctuation">::</span></span><span class="token class-name">CounterExt</span><span class="token punctuation">;</span>\n\n<span class="token keyword">fn</span> <span class="token function-definition function">process_message</span><span class="token punctuation">(</span>key<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> message<span class="token punctuation">:</span> <span class="token class-name">ProtobufMessage</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>\n    <span class="token keyword">match</span> cache<span class="token punctuation">.</span><span class="token function">get_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>\n        <span class="token comment">// We have an entry, merge the counter</span>\n        <span class="token class-name">Entry</span><span class="token punctuation">::</span><span class="token class-name">Occupied</span><span class="token punctuation">(</span><span class="token keyword">mut</span> cache_entry<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>\n            cache_entry<span class="token punctuation">.</span><span class="token function">get_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>\n        <span class="token comment">// No entry, insert it</span>\n        <span class="token class-name">Entry</span><span class="token punctuation">::</span><span class="token class-name">Vacant</span><span class="token punctuation">(</span>cache_entry<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>\n            cache_entry<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">&#125;</span>\n    <span class="token punctuation">&#125;</span>\n<span class="token punctuation">&#125;</span></code>',y(a,Ia,d),y(a,La,d),b(La,Ma),y(a,Wa,d),y(a,Na,d),b(Na,ja),y(a,Ba,d),y(a,Ka,d),b(Ka,Sa),y(a,qa,d),y(a,Ha,d),b(Ha,Ga),y(a,Ua,d),y(a,Ya,d),b(Ya,Fa),b(Ya,Qa),b(Qa,Va),b(Ya,Za),b(Ya,za),b(za,Ja)},p:P,d(a){a&&w(n),a&&w(e),a&&w(t),a&&w(c),a&&w(p),a&&w(u),a&&w(i),a&&w(_),a&&w(A),a&&w($),a&&w(O),a&&w(M),a&&w(W),a&&w(q),a&&w(H),a&&w(Q),a&&w(V),a&&w(Z),a&&w(z),a&&w(ra),a&&w(ua),a&&w(ha),a&&w(ma),a&&w(ga),a&&w(wa),a&&w(va),a&&w(Ea),a&&w(xa),a&&w(Ta),a&&w(Aa),a&&w($a),a&&w(Ra),a&&w(Da),a&&w(Ia),a&&w(La),a&&w(Wa),a&&w(Na),a&&w(Ba),a&&w(Ka),a&&w(qa),a&&w(Ha),a&&w(Ua),a&&w(Ya)}}}function T(a){let n,s;const d=[_];let k={$$slots:{default:[x]},$$scope:{ctx:a}};for(let t=0;t<d.length;t+=1)k=e(k,d[t]);return n=new C({props:k}),{c(){t(n.$$.fragment)},l(a){o(n.$$.fragment,a)},m(a,e){c(n,a,e),s=!0},p(a,[s]){const e=0&s?p(d,[l(_)]):{};1&s&&(e.$$scope={dirty:s,ctx:a}),n.$set(e)},i(a){s||(r(n.$$.fragment,a),s=!0)},o(a){u(n.$$.fragment,a),s=!1},d(a){i(n,a)}}}const _={title:"Extending Protobuf with Traits in Rust",date:"2019-04-18T00:00:00.000Z",summary:"Extend default behavior of code with Traits and default implementations. In this case we add new functionality to generated Protobuf code."};export default class extends a{constructor(a){super(),n(this,a,null,T,s,{})}}export{_ as metadata};
